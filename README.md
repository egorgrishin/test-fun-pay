# Тестовое задание для компании FunPay
Было необходимо реализовать функцию для формирования SQL-запросов в файле Database.php и выбрать аргумент для метода skip().

Текст задания был перенесен в файл TASK.txt.

В ходе решения данной задачи было реализовано 2 алгоритма формирования SQL-запросов с параметрами и условными блоками.
Опишу каждый из них.

## 1. Алгоритм замены исходной строки
Суть данного алгоритма заключается в том,
что с помощью функции substr_replace() происходит замена подстроки в SQL-запросе на отформатированный параметр/условный блок.
Если у параметра (вопросительного знака) есть спецификатор, то 2 символа заменяются на отформатированную строку. Если спецификатора нет — заменяется один символ.

Для работы с условием необходимо запоминать индекс начала условия. Если по итогу условный блок необходимо оставить, нужно просто удалить фигурные скобки.
Если же его необходимо удалить, то удаляем подстроку, начиная с записанного индекса и заканчивая текущим (так как окончание условного блока мы видим, когда встречаем закрывающую фигурную скобку).

Для корректной работы нужно контролировать позицию курсора в SQL-строке.

Преимущество данного алгоритма в том, что он не делает никаких манипуляций, когда нет необходимости как-то менять SQL-строку.
Например, он проходится по "DELETE FROM" — параметров и условий тут нет, никаких преобразований не будет.

Недостаток заключается в том, что в дальнейшим могут возникнуть проблемы с расширением функционала.

## 2. Алгоритм копирования строки
В отличие от предыдущего алгоритма, этот не изменяет исходную строку, а создает новую (result).
Когда попадается символ, который не нужно преобразовывать, он просто попадает в эту строку.
Если встречается параметр, он сначала форматируется, а потом точно также добавляется в конец результирующей строки.

Отличается тут логика работы с условными блоками. Текст условий кладется в свойство condition. Когда курсор доходит до конца условного блока, возможны 2 варианта:
1. Если условный блок подходит, его текст добавляем в конец результирующей строки.
2. Если условный блок необходимо пропустить, его добавление никуда не происходит.

Чтобы не прописывать условия, когда конкатенировать нужно с result, а когда с condition, было добавлено свойство text.
Оно является ссылкой на ту переменную, в которую в данный момент нужно класть символы. В условном блоке — на condition, в остальных случаях — на result.

Преимущества данного алгоритма заключаются в том, что он проще предыдущего и к нему легче добавить новый функционал.

Недостатки: немного медленнее.

### Общие моменты
1. У обоих алгоритмов имеется свойство isSkip — флаг, обозначающий, нужно ли оставлять условный блок или его необходимо удалить.
Также, если какой-либо из аргументов в блоке имеет значение, равное skip(), то все последующие аргументы в блоке форматироваться не будут из-за ненадобности (блок все равно будет удален).
2. Оба имеют свойства inQuote и inCondition — флаги, которые показывают, находится ли курсор сейчас в кавычках, условии или просто в тексте запроса. Они были добавлены, чтобы не было необходимости производить сравнение свойств quote, condition и startConditionIndex c NULL.
3. Текст, находящийся в кавычках (одинарных и двойных), не обрабатывается. Текст в обратных кавычках обрабатывается.

По итогу я бы выбрал для использования алгоритм копирования, так как он более прост и его будет легче обслуживать.

Алгоритмы были написаны в классах QueryReplace и QueryCopy соответственно.
Были написаны дополнительные тесты — они находятся в директории tests. Все пройдены успешно.